// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3fbtrIo/lXw0zlr5XFEyXl1N16r6/zcOG19d5JmxW7PvifObSFyJGGbBLgB0Jaa",
	"6+9+FwYACZKgJD+SND3+K7EIDAaDwWAwM5j5OEpFUQoOXKvR/sdRSSUtQIPEv2iaiorrhGXmrwxUKlmp",
	"meCjff+NKC0ZX4zGI2Z+LalejsYjTgto2pj+45GEf1VMQjba17KC8UilSyioAazXpWldQ1olC5E4EAcW",
	"xNHh6HLDB5plEpTqY/kzz9eE8TSvMiBaUq5oaj4pcsH0kuglU8R1JowTwYGIOdHLVmMyZ5BnauIn+a8K",
	"5DqYpRt8eEqXDYqJFDn08Xwhihnj4LGCGql6QYgWJIM5NlpSTcwIBlffUAuigMp0SeZCbkHVIhHiC7wq",
	"RvvvRwp4BhJXKwV2jv+dS4A/INFULkCPPoxjk5trkIlmRWRqR476ElSVa0WwLc5xwc6BE9NrQl5XSpMZ",
	"EMrJux9ekCdPnjw3Eymo1pA5JhucVTN6OCfbfbQ/yqgG/7nPazRfCEl5ltTt3/3wAsc/dhPctRVVCuKb",
	"5cB8IUeHQxPwHSMsxLiGBa5Di/tNj8imaH6ewVxI2HFNbONbXZRw/C+6KinV6bIUjOvIuhD8SuznqAwL",
	"um+SYTUCrfaloZQ0QN/vJc8/fHw0frR3+W/vD5L/dn8+e3K54/Rf1HC3UCDaMK2kBJ6uk4UEirtlSXmf",
	"Hu8cP6ilqPKMLOk5Lj4tUNS7vsT0taLznOaV4ROWSnGQL4Qi1LFRBnNa5Zr4gUnFcyOmDDTH7YQpUkpx",
	"zjLIxkb6XixZuiQpVRYEtiMXLM8ND1YKsiFei89uw2a6DEli8LoWPXBCf15iNPPaQglYoTRI0lwoSLTY",
	"cjz5E4fyjIQHSnNWqasdVuRkCQQHNx/sYYu044an83xNNK5rRqgilPijaUzYnKxFRS5wcXJ2hv3dbAzV",
	"CmKIhovTOkfN5h0iX48YEeLNhMiBciSe33d9kvE5W1QSFLlYgl66M0+CKgVXQMTsn5Bqs+z/6/jnN0RI",
	"8hqUogt4S9MzAjwV2fAau0FjJ/g/lTALXqhFSdOz+HGds4JFUH5NV6yoCsKrYgbSrJc/H7QgEnQl+RBC",
	"FuIWPivoqj/oiax4iovbDNtS1AwrMVXmdD0hR3NS0NV3e2OHjiI0z0kJPGN8QfSKDyppZuzt6CVSVDzb",
	"QYfRZsGCU1OVkLI5g4zUUDZg4obZhg/jV8On0awCdDyQQXTqUbagw2EV4Rmzdc0XUtIFBCwzIb84yYVf",
	"tTgDXgs4Mlvjp1LCOROVqjsN4IhDb1avudCQlBLmLMJjx44cRnrYNk68Fk7BSQXXlHHIjORFpIUGK4kG",
	"cQoG3HyZ6R/RM6rgm6dDB3jzdcfVn4vuqm9c8Z1WGxsldktGzkXz1W3YuNrU6r/D5S8cW7FFYn/uLSRb",
	"nJijZM5yPGb+adbPk6FSKARahPAHj2ILTnUlYf+UPzR/kYQca8ozKjPzS2F/el3lmh2zhfkptz+9EguW",
	"HrPFADFrXKO3KexW2H8MvLg41qvopeGVEGdVGU4obd1KZ2tydDi0yBbmVRnzoL7KhreKk5W/aVy1h17V",
	"CzmA5CDtSmoansFagsGWpnP8ZzVHfqJz+Yf5pyzzGE0NA7uDFo0Czljwzv1mfjJbHuydwEBhKTVEneLx",
	"uf8xQOjfJcxH+6N/mzaWkqn9qqYOrhnxcjw6aODc/khNTzu/zkWm+UwYt6uDTcf2Tnj7+BioUUxQUe3g",
	"8H0u0rNr4VBKUYLUzK7jzMDp7xQET5ZAM5Ako5pOmkuV1bMG+B07/oT98JYEMnLE/Yz/oTkxn80upNqr",
	"b0Z1ZcoocSIwNGVG47PniB3JNEBNVJDCKnnEKGdXwvJFM7gV0LVEfe/I8qELLbI6L61eSbCHn4SZenNr",
	"PJgJeT1+6TACJ81dmFADtdZ+zczbK4tNqzJx9Ino07ZBB1BjfuyL1ZBCXfAxWrWocKzpJ6CCMlBvgwpt",
	"QLdNBVGULIdb2K9Lqpb9SRgF58ljcvzTwbNHj397/Owbc0KXUiwkLchsrUGR++5cIUqvc3jQnxkK+CrX",
	"cejfPPU3qDbcrRRChGvYu+yoEzCSwVKMWHuBwe4QctDwlkrNUlYitY6ykKJtKK2G5AzWZCE0yRBIZk96",
	"hCrXsuK3sDAgpZARTRoZUotU5Mk5SMVExCjy1rUgroWRblab7/xusSUXVBEzNl7yKp6BnMTW09zeUFHQ",
	"UKhtx48FfbLiDcUdQColXffW1c43Mjs37i4r3Sa+vzMoUoJM9IqTDGbVIjz5yFyKglCSYUcUs29EBsea",
	"6krdgmxpgDXImIUIUaAzUWlCCReZEROmcVzqDFhI0TSDFiUdCjK9tKfaDIzOndJqsdTEKKsitrRNx4Sm",
	"dlESPIHUwIWytgTYVnY4a33LJdBsTWYAnIiZu7W5+yROkqKxR3s/jpN5DVr1TaOFVylFCkpBljin1VbU",
	"fDu7ynoDnRBxRLgehShB5lReE1ktNM23IIptYujWSoq76vax3m34TQvYHTxcRirNzdVygdGIzO42Ym6I",
	"hDvS5BwkXvk+6fr5Qa67fFU54JBx5/oJK8z2JZxyoSAVPFNRYDlVOtm2bU2jlvJhZhDslNhORcADZodX",
	"VGl78Wc8Q0XUihscB/vgEMMID54oBvKv/jDpw06NnOSqUvXJoqqyFFJDFpsDh9WGsd7Aqh5LzAPY9fGl",
	"BakUbIM8RKUAviOWnYklENXO8lRbxvqTQyO/OQfWUVK2kGgIsQmRY98qoG5olB5AxNxa6p7IOEx1OKe2",
	"hI9HSouyNPtPJxWv+w2R6di2PtC/NG37zEV1I9czAWZ07XFymF9Yylp3xJIajREhk4KembMJ9T9roejj",
	"bDZjohhPIdnE+WZbHptW4RbYskkHVG/n8AxG62yODv9GmW6QCbaswtCEB+4BLaX077C+dSNCd4CoPYFk",
	"oCnLISPBBxTgKHsbrZllowjS11O0dlJC++j3tNDIdHKm8MAouyq/QvStL+Mk8IDcgqYYgWp2N+UEEfUW",
	"UnMgh01gRVOdr80xp5ewJhcggahqVjCtrXOqrUhqUSYhgOh1eMOIziBh/QB+BXaxkBwjqGB6/aUYj6za",
	"shm/k47i0iKHU5hKIfLJ9h3fI0YUg10uHgekFGbVmfOFeoeZ56QWkk6JQWtULTzvqRaZcQbkf4uKpJSj",
	"AlZpqE8EIVHM4vFrRjAHWD0ms5pOQyHIoQCrV+KXhw+7E3/40K05U2QOFz6AwDTskuPhQ7wlvRVKtzbX",
	"Ldx4zXY7ish2tBOYg8LpcF2ZMtlqM3CQd1nJ9jX/6NAPintKKce4Zvo3FgCdnbnaZe4hjyypWm6fO8Ld",
	"yUwSgI7N2667FGJ+S2anuAMJLyfOJ2RakXnFLVKVctcRDDXwBg0xH40bd05VOPuQWlJnuop4H8Yjlq1i",
	"XrsMVjFKu42Dd6R75kKxVqAnUd3PYtR33IM8yx2+HYFACjA7VS1ZaUA2Tsa1hlaA0v+5/5/77w+S/6bJ",
	"H3vJ8/+Yfvj49PLBw96Pjy+/++7/tn96cvndg//895i+rDSbxU2APxnaizlxgnvFj7g14s+FtLestVPe",
	"xPxz4x0xCTovlVlXvwjB7Hba+bG1YZxQu+7I/kZNz9e3cNxbQERCKUGhcA6vt8p+FfMwVMkxoVorDUXf",
	"QmS7/jagH7/z2mWPYQXPGYekEBzW0ehcxuE1foz1tgfEQGc8qof6drXvFv4dtNrj7LKYN6UvrnYgEd/W",
	"gVO3sPhduB3jYBikhcYNyEtCSZozNH0IrrSsUn3KKV6uAnaNuCv8lXH4uv3CN4nf7yPXbwfqlFNlaFhf",
	"uaJG4zlEhPwPAP7WrarFApTuqJlzgFPuWjFOKs40jlWY9UrsgpUg0WcwsS0LuiZzmqN14A+Qgswq3Va8",
	"MJZEaXN5t5ZKMwwR81NONcmBKk1eM36yQnA+ZMPzDAd9IeRZTYW4+F8AB8VUEpepP9qvKFrd9JdOzGJg",
	"r/3s5c3nPgs87rFIB4f50aG7lBwdoubZ2Ch7uH82w1XBeBJlMqNJFIxjwFyHt8h9oz97BnrQWDvdqp9y",
	"veKGkc5pzjKjbVyHHboirrcX7e7ocE1rITp2CD/XDzG39EIkJU3P0Cs5WjC9rGaTVBRTfxmbLkR9MZtm",
	"FArB8Vs2pSWbqhLS6fmjLZrhDeQViYiry/HISR1166YLBzg2oe6YtQXQ/60FuffjyxMydSul7tmwJws6",
	"iFeJ3J/dq5uWi8dM3obt27ivU37KD2HOODPf9095RjWdzqhiqZpWCuT3NKc8hclCkH3iQB5STU95T8QP",
	"vqzBoGSHTVnNcpaSs/AobramjZbuQzg9fW8Y5PT0Q89f0D843VDRPWoHSC6YXopKJy4cNJFwQWUWQV3V",
	"4YAI2QZzbxp1TBxsy5Eu3NTBj4tqWpYqyUVK80RpqiE+/bLMzfQDNlQEO2EUC1FaSC8EjWS02OD6vhHu",
	"kiLphY8lrhQo8ntBy/eM6w8kOa329p4AOSjLVwbmscHjdydrDE+uS2hZWnaMP2qAxawsOHGrUMFKS5qU",
	"dAEqOn0NtMTVx4O6QJtenhPsFtKk9uEjqGYCnh7DC2DxuHKEFU7u2Pby73riU8BPuITYxkinxlR+3fUy",
	"oH4SuWGyay9XACO6SpVeJmZvR2elDIv7lanD/RdGJnv/hWILbjaBexkxA5IuIT2DDIO0oSj1etzq7l1k",
	"7oTzooMp+5jBBlJhxC0apWZAqjKjTgegfN0NfVSgtY/3fAdnsD4RTcDuVWIdL8cje+fPEsMzQxsVOTU4",
	"jAyzhtvWweguvnO3GkxpWZJFLmZud9dssV/zhe8zvJHtCXkLmzjGFDUZNvB7SWWEEJb5B0hwjYkaeDdi",
	"/dj0jHozsydfxITiZT9xTRqtzblMw9mcLOvvBeDLKHGhyIwqyIhwj3rs+5hAilWKLmDArhPaBXcMOm3Z",
	"EhHItnMvetKJefdA6503UZRt48TMOcopYL4YVkHDWsdR7keypmecwYTgW11HsFmOalLto7dCh8qWfdY+",
	"PhxCLc7AIHmjcHg02hQJNZslVf69ET7L8nt5Jx1gyJtYe4MNg3t3MF5FG6WOmXFzOKdD9B8Okj8KfLzB",
	"26s6BN7L3O4+HdfPIewzaB8q7+PjfVB8aBHdIcB9PHJhR7HlEBwVoAxyWNiJ28aeURxq91SwQAaPn+fz",
	"nHEgScxdTJUSKbMPxppjxo0BRj9+SIi1PZGdIcTYOEAbXSoImLwR4d7ki6sgyYGhD4Z62OiMCf6G7Tb5",
	"5j2607y3asht2diXJM2WGjevR+yi9s1l41FUQA1dZdouEdtkBr27X4xhjaDqG5D6ZioFOaDekLTkbHIW",
	"Mysa9QeQKY99t+B+Q+6zudFGHgR+NgkLpjQ0F3yzd73F6nMb3Cm+ShJiPjw708bMTwpRczL+6BwI4TQ/",
	"+wzOhYZkzqTSCVpHolMwjX5QqHf/YJrGxWnHk6esuSUuTXHYM1gnGcurOL+6cf9+aIZ9U19VVTU7gzUe",
	"mkDTJZnhg/Kof3/D0DYEZOOEX9kJv6K3Nt/ddoNpWrNLe4yvZF905OMmcRBhwBhz9FdtkKQbBCReMw8h",
	"17F3A4HiaDdnZhpONhloepsp87A3qZMBFsMniYUUnUtwp9g4C4b+T6MUMx28x+6HIw/sAVqWLFt1zCUW",
	"6qBSTa90J7KXqx4VcHUdsC0UCEwjsYg3Cd68Y5c00AHsy3oezm2yE2WMNhkSJBAI4VBM+bwwfUIZ1sbk",
	"BdtodQI0/zusfzVtcTqjy/HoZtaVGK0dxC20flsvb5TO6Dawt+2WsfSKJKdlKcU5zRNngxpiTSnOHWti",
	"c2+y+syiLm7pOHl58OqtQ99c83OgMqlVhcFZYbvyq5mVBKMtD2wQn3fCaN/eTGFVyWDx68d8od3qYgnu",
	"jX+gjRop5pjLbq/GJhlsRWfHmse9l1utUs58aqe4wYwKZW1FbW741ojaNpzSc8pyf7X22A54GnFyjen6",
	"ylIhBHBjA2xgR09uVdz0dnd8dzTctUUmhWNtyEJQ2EQbigjejaYzKiTe2JFVC7o2HGT9AH3hxKsiMdsv",
	"UTlL42YYPlOGObg1r5vGBBsPKKMGYsUGvDW8YgEs00zt4JjsIBmMESUmWu820G4mXIa0irN/VUBYBlyb",
	"TxJ3ZWejmn3ps+z0j1OjO/THcoCtEa8BfxMdw4Aa0i4Qic0KRmjM76F7WF+Z/URrL4T5IbBaXsEnGI7Y",
	"OxI3+PMcfzhutoEVy7ZRPkxo1pd/hjFs8ovt2dT85XVpER0YI5odbfC0OBg+KUzvK5wRzZGA6IaHwdja",
	"hnMlImAqfkG5TXZk+lkaut4KrNXD9LoQEt/3KIgGRDCVzKX4A+I32blZqEjAryMlqovYexJ5N9EVorWV",
	"qUlj5+kb4jHI2kOaXPCRtH22AzscuTzwUuAzfG+wo9yytU3M1IoUiG+OMLpnauE3m8Ph3IuIyunFjMZy",
	"FBiFyuB00PjDWqZFLYjv7FfBWUEb3gtca3VbZh/FlCCbqPz+A8xrKkdfF8tnkLKC5nEtKUPqt58AZmzB",
	"bHarSkGQPskBsmkBLRe5FFTW49iQ5mhO9sZBgja3Ghk7Z4rNcsAWj2yLGVV4atVGt7qLmR5wvVTY/PEO",
	"zZcVzyRkeqksYZUgtQKLV7nalj8DfQHAyR62e/Sc3EcvhmLn8MBQ0ekio/1Hz9EMbP/Yix12Lo3dJrmS",
	"oWD5LydY4nyMbhwLwxxSDuok+kDL5h4dFmEbdpPtustewpZO6m3fSwXldAFxx3mxBSfbF1cTjYYduvDM",
	"Js5TWoo1YTo+Pmhq5NNAFKARfxYNkoqiYBodlFoQJQrDT01uJDuoB2ez8Ll8JR4v/xFdRqW9NkD3wvx5",
	"DcT2LI/NGh17b2gBbbKOCbXvGHPWOHOdQJyQI/8aGhO41HlbLG3MWGbqqNKhb3dOSsm4xktUpefJtyRd",
	"UklTI/4mQ+gms2+eRpLWtPNU8Ksh/tnpLkGBPI+TXg6wvdcmXF9ynwueFEaiZA+aqNtgV0bzQghN83j8",
	"kJfo3fCxzaB3VUANlGSQ3aoWu9FAUt+I8fgGgDdkxXo+V+LHK8/ss3NmJePsQSuzQr+8e+W0jELIWG6M",
	"Zrs7jUOClgzOMZQpvkgG5g3XQuY7rcJNsP+yXpbmBlCrZX4vxy4C31csz35tXhF08n5JytNl1McxMx1/",
	"axIV1lO2+ziaimFJOYc8Cs6emb/5szVy+v9T7DpOwfiObbv5vOx0O5NrEG+j6ZHyAxryMp2bAUKqtsOq",
	"6zi8fCEyguM07/4bLuunKAuyEP2rAqVjSZPxgw1hRVuWuRfYJDgEeIZa9YT8aBONL4G0niWjNsuKKrdP",
	"XCFbgHRG1qrMBc3GxMA5eXnwithRbR+bENYm4VmgMteeRceGESQJ2S2qzGf6i0e87g5ncwiembXSmCVA",
	"aVqUsccMpsWJb4AvJkK7Lqp5IXUm5NBq2Mrrb3YQww9zJgujmdbQrIxHnjD/0ZqmS1RdW9JkmOV3zx7l",
	"uVIFuVnrNJd1ng/cdwZvl0DK5o8aE2HuFxdM2fzScA7t9xP1YyJ3dfLvKdrTkxXnllOiMnrTY7frkN0j",
	"Z5333vQbxaxD+CsqLkpUMoWrJtM6xl7Rh/PdzFy9pKz2DWedFNHXDUgpF5yl+Gw9yGhdo+xyVe/iF9nh",
	"hX/XLOW3uNuhkc0VzQdWBzg5Kg5mCPOC0BGub5gNvppFtdxh/9SYFHlJNVmAVk6yQTb2meScvYRxBS5v",
	"C6YtD+SkkC1fE0rIqPsyqc3cV2QjjKYeUIB/MN/euOsRhhmeMY6KkCObi2i0Fg1MpauN9sQ0WQhQbj7t",
	"h9DqvekzwcfAGaw+THzqXYRhXTVm2tYv2Qd14L2Uzito2r4wbQm6ZZqfW5HbdtCDsnSDRsOq6hWOZa0b",
	"JHDE25R4c39A3Bp+CG0Du20ML8Dz1DAanKNzEko8h3uMUScA7OQHPad5ZTkKWxAb1hN9ccd4BI1XjEOT",
	"GDpyQKTRIwEXBvfrQD+VSqqtCriTTDsBmqNHMibQlHYm2puC6iwwkgTn6McYXsYmd+GA4KgbNIob5es6",
	"H7Xh7kCZeIGJ8B0h+5kIUatySlSGgaid3IQxwWEEt88V2j4A+tugrxPZ7lpSu3OuchINvS1KRUzffLmC",
	"tLIOd2ETotCyJCk+1g3Oi6hFkylzeSpmeST27bD+GKQRxaDh2Rr/jaWpGSaJ84hfOSbLu7+x45UV1jak",
	"nrppmClRbHHNZW763+o652LRRuTzGhQ27vGQZWK7+6URm8OJXg+8YK1fg2IYkvA5pvHSVL9jau9JFOTR",
	"S2mTLnjzpXw48e8YRf9AMOK7JtEBtaeL9TEMhSSmgxG0VLtwf01Jk1WgvzFttt4YBBvPYLME24o7UfvK",
	"UAyDDWEwn3u9d9OLelomwt5IUB8c00fo7z7yjpSUOQdas2P7lHUxuv2o6V2i95oF7k7CRb4ikNhMeonO",
	"NnNIL/I5iN63+agmu78zbhzy6DPBbMIL4C6dcDumcefIqvkcUs3Ot0Sa/5fRWJso5rHXaW1m9yDwnNWR",
	"Or4w0xVV7QahTYHgG/EJkhncGJ2hONMzWN9TpJ3U+jC6/xyjXucZG1IAEz0khkWEiln/7SXcGWSZqjkD",
	"qeC9bbY7NDl2BjOTBu8mrjmWZ0lCw7cUG4Y8FzEtfqexTNcdAq+a6G0MyRgKRu/nBhw+vQ4xFaOqs0rX",
	"lZeCYApzWeumuLpwz+jwXUBtd/IP6kD53/wjIDuKrejV5E5FK98FlZlvEVVbvUacDIR3dQOmbVw6iyM9",
	"r0dmTWxEP2Y48vwcY2HSXCjGF8lQyFQ7HKG25d9T1umCBgJMuoh4zUG6nMnaF0xLtPCxFJvw2EQKV6/j",
	"OkRQg4nKLHKDDzHfNS9NMecOteXynEMpnCCRUFCDnQzegw6PuYnYL+x3HyTrc650MhxF4Hp+TbY+6PRR",
	"MUz1iBhy/Zy403J78O117guMc5uSXsUeh3JDytCSVEqRVak9oMONAf5etfPT6w2iJKrlp/1Z9hS2HBMR",
	"vAqeMpzBemqVpnRJeZMRor2tbWZ6O4fg6WBntW/1KhVXWPOFncDiVvD8kjeh8agUIk8GTEdH/Teu3T1w",
	"xtIzyIg5O7w/eSA7KbmPFovaN3CxXPtc7GUJHLIHE0LMXaoo9dq7CdrZnTqD83t60/grHDWr7LNzd0mb",
	"nPJ4KIQtQHlD+ebBbJZqtiLzDYeyQDYPpFd8QLTRi0iu3l2LF0UM9938qQ1TWSxiWso138rttL/7F7UI",
	"64evHLbcf85atzqbv6RjrBcSbvl2F1gpr3i767/f2HV6OA+UapWC/jx3XoAWbQdovwvhG9NEn7jDFgU9",
	"28WiEM+1YLqjScMSBBOVEESV/P7odyJh7qrhPnyIAzx8OHZNf3/c/mxuXw8fRnfmZzNmtGokuXFjHPPr",
	"kHPXOjAH4gg661GxPNvGGK2okCaJIMY9/ObiZ75IGsPf7BW5v1VdRrermFG7i4CEicy1NXgwVBDvsUOo",
	"h+sWCezAwyatJNNrfMLkb1Tst+jT8B9rI4wrvFcHgrs4ZFvz1YUlNSabpkznj8KWzirMWY+GdY2JyV+u",
	"aFHm4DbKd/dmf4Mn3z7N9p48+tvs271neyk8ffZ8b48+f0ofPX/yCB5/++zpHjyaf/N89jh7/PTx7Onj",
	"p988e54+efpo9vSb53+752tkWkSb+pP/wFyfycHbo+TEINvQhJasrkdg2NjnDaQp7kRzJ8lH+/6n/9/v",
	"sEkqiqCsv/t15GLURkutS7U/nV5cXEzCLtMF3tESLap0OfXj9PPAvz2q42fsuwdcURsaYVgBF9WxwgF+",
	"e/fy+IQcvD2aNAwz2h/tTfYmjzA9bwmclmy0P3qCP+HuWeK6Tx2zjfY/Xo5H0yXQXC/dHwVoyVL/SV3Q",
	"xQLkxCVQND+dP5569/v0o7ufXhqoi9jjLhsJFIR/9PMKOlsXOnV86ecgP4xyaWPGdfYmpz7yDAM07JXP",
	"iLaaWEdZk4PkKKhW6V5i2afp+++/orLesVoLsQSNkWq9jalouFBvI1eNrNxLnn/4+Ozby0gc4IdO8dXH",
	"e3ufoODquAXF0+WalVuf3iKKbQfQjRHtgutJhdc0N3wDdTH+EU7o0Vc7oSOO9m8jtogVy5fj0bOveIWO",
	"uNk4NCfYMnhJ0xeFv/AzLi64b2mO5KooqFzjgRukTQxVq8tBkdt+w+astcNyGIKqH0FeuJa1aLb2fDYm",
	"qi4NVUomjOIwNreADFIJFI95ITFcr6kf4iwDYGthvT74B9qLXx/8g3xHhsr6B8PbG3lbiP8IOlLf5vt1",
	"U5p6o0T/UmJy3E/c7ok0UH9GC/8MDYlW0NV3QyRb8cFi+gVdbSn+/vWceTc9au6qJH21VZJ2ENp3q3tX",
	"A+urrYH1daukq/r9MSVc8IRjnsxzIIFZ605H/VPrqM/2nny1szkGec5SICdQlEJSyfI1+YXXDzZupoLX",
	"MqfiwROajfKn595qtOhAfQ/SiU8/tiIZsu3Gk1ZIQzYmTDeaYSvaIcgxXKczdo/1xk2mL8ozG2jvI1/V",
	"2Ge8Qmud9cfa9Rj38mFNYkp64Kb5fn10uIte3ppTkIgnppu36LVRRe8dWp/UYhE++Iqca/G1+dQnQA+P",
	"72lG/Iu+TyybdxOmT/eefj4MwlV4IzT5AQM9PrFI/6R2gjhbBcIGU/ZPP/qcPTsIGJcPqy1aXPTQRqFi",
	"dujYPdJ3xdFq776RJ1YQ2pRkfalhRthVXvRTdsUkRZOm6M8iI2zJgghfdsl7Jxfu5MKN5EKXoRqJgDGy",
	"avoRI9lCcdDbklip8y/kKAkKMkhR+Ay6gsxBp0sbO9z1ZUfEin83OixTNmVXurF86XjXcYn62SVwLs5f",
	"i1l/doziwY4/Wffp5XiUgoww38/+EYv5zOYYi1W/CfZJxDCTBvN5NeqUGi7xEFPEMKgWxD1VIWYVr4Tl",
	"i2bwvm8dyXI9a9IdgW9C4J5Qe+kynNjt5SbxtRs+gtOSJOQNqkO4wf2T2L+i2eNTnsifekJvBAcCK6aw",
	"UIvlxTt3Y60u1HXJ69DlsM7kgOrQdjp+1CuWXU7rtzVDSsVbV1V7o1LRnNSsyXTfNq/QsgQq1bUP6e3u",
	"sJPOiEeHYSWO1lOg+hFQBBVDlyt6Ev9jFzfiX9dbd1fk/67I/1df5P+z3t6b2CArNb3LSnYE2Be92usv",
	"crV/I3iCBz9w7ZXQFlm+3DUf30K0qg36dFZcaLSgCYn6SigS1GSnkx4GvRot+YLRpcNs7M79lOp0WZXT",
	"j/gfjEu9bCJAbe62qbX4bTr6j22LW43lsDCJbJ4HhKHQzgoZrfms1kpD0c/sbbv+tikrWFScCyw0mBSC",
	"x6KobRnC1/gx+ioH/cMDndFTP9S3m4+xhX8HrfY4u4i6m9J38uewJt5IM+7MVkJZx8Nh4ADyf7NbukVe",
	"Yz9PP7YriFnDvGuplpXOxEXQt6msObi3bItb3VtvRAYWbvuhQT87KcXICxec3d9StdSI63Cevk07+waQ",
	"KfdqMqXVYqltZupo2vu6Y0JTuxVsZgG17Sm2beWfHJ4DobkEmq3JDIATMTOTbqe06NYGdbIx/qK4wauU",
	"IgWlIEvClJSbUKtD3tFYqTfQCRFHhOtRiBJkTuU1kbVCYjOi3VzMNbq1ScrJgT7Wuw2/aQG7g4fLSGVQ",
	"09ncAURR5uBuARES7kgT1GPZJ14/P8h1l68qMeth5E28/XrCCny/xykXClLBMzWcuWLbtsVcFcFcFNhE",
	"/36nRJPJGcADR+srqrRLutl64BtkPDFDbEi1MfRczUD+tX6s1oPd1Jat85Fa3QuyaKp3WG0Y6w2s6rHE",
	"PFK31pWh2AZ5iEoB/DpDaZA7QwfmEgMuMrkLlufoOI5rIi0kGkJsQuTYtwqoG9okBhBhqiF0/SC+zTlB",
	"iQilRVma/aeTitf9hsh0bFsf6F+atn3mclHqKNczASpUvB3mF5ayNvnwkiri8CAFPXM6+8IFi/dxNpsx",
	"UYynLuHPUGIJVsCxaRVugS2btKv2hdu/tc86m6PDv1GmG2SCLaswNOGYovmnUAuveu/rGhc+oU22rWgH",
	"6lWjaNq/pxeU6WQupEumhOVtIu7dTo4pyrQrquRuxVo4m6orkGMFioMTpN5WYaStq+Lu80CwIhISZob6",
	"QcidvMmN4VcLYiZGKq6Zfwto9lutY/75XLN32vOd9nynPd9pz3fa8532fKc932nPn1p7/jLhoSRJvJz2",
	"b39iL3/I6KvU8L+ixzWf8zVMo/TXKj9eEoyKbvbxxrARDTSfuoIX6N+Ppne38edh8YzUDMc4KXOKlTNX",
	"2r+CxqKZQfksn7XdJncyssY0ePKYHP904Hz7NkIAK3iFbe/7vMNKr3N44MLr6uwrPs4OOMX08BhmR/3t",
	"J/UhGFabn7MciDLEeonND+EccqPKW+8nMZeR/vXoBGj+whHHSiVQ+nuRrTuMY+Y/RVK0WabxpjNOZaSE",
	"Q59RekTWAsu4uJokvRvU5a0HdPSXv79g29ZqoHphlL038ctOQQOjGvYuXjOzpp6cxJV/+KIimyBGjs0a",
	"8fSnCfPvph92GwfbGq3C7b+vNSTfEz668XDbjn16VoKl1C3HrRLTaAE8cWIhmYls7cucu2oyLSlry3wM",
	"C1lbQwNckSK3De6rB0bMIkVXumXqiZZZC0oSNrljv4zgtAUmNsrN63NHu/7djQM6u+D6UiMIw7gvJFlI",
	"UZUPbEFtvsYrcVFSvvZmMKMrYgE9TKaNQei3K6nrDLA9Obt7/bfwvuLi8Nq/W7Jg3lhX/C2z1d/i6Rm7",
	"Ncq2U7ypwLMtJZ9PThqpFjZQG6y/iH6VXRRmbforbarmSM2eToWeu5df/yOOhLdSnDNzcY5K2H5cViMQ",
	"JltPBhmILDwaOnlA/NnQlqfv6MVJq47SbjJ1lTjF88Za6RJQIau1tEjSFHNeSkGzlCp83OLKKn5ijVWv",
	"jiJ2B0QTk1/1w4DNAT7Zqlgi3J30yXYYuhsQs9Mom+Xzy2qXTfzpgXtL1KLGnSngr2IK+N5vPkUoJgzv",
	"bM6g1OkOYope6BWPSqkpegmHI96CDfHWtrxV310PfNuF17gwnQsC8pJQkuYMHRSCKy2rVJ9yiibQTjb1",
	"jnvPG3aHVakXvkncCh8xkjtQp5xiefzaMBpVqeYQK/wJ4DU2VS0WoHRHEs8BTrlrxXhTih+T0yc2EtQc",
	"10aiT2zLgq7JHMv1CfIHSEFm5hYRJlRBg6LSLM+dP9EMQ8T8lFNNcjBC/zUzCp0B521OtY/cldj1VBgo",
	"umHT3SZxK8SP9iu+aHDT93YjNG/Zz02doS+SlDqJ1W1ymB8dumRnR4eYv6bxJPZw/2zupYLxJMpk5sR3",
	"Hvkub5H7RsfzDPSg8Um6VT/lRpnWgqCgp/p67NB1A/T2ot0dHa5pLUTHW+Dn+iH20HYhEnNlxBJ+owXT",
	"y2qGaaH9A9zpQtSPcacZhUJw/JZNacmmqoR0ev5oi35wA3lFIuLq7uT+6xjxQz4wu6VeeKyW1F37gXP5",
	"FnLL/rkTym4NUbpL33qXvvUuwedd+ta71b1L33qX3PQuuen/1OSmk40aoksIsjXdYOvtcYahn00J2VqA",
	"h81aiQn7bkmmJ4ScYIFOas4AOAdJc5JSZRUjV3G3YIulJqpKU4Bs/5QnLUxSUbiB7zf/tdfc02pv7wmQ",
	"vQfdPtZuEUjefl9UVfGTLQ7/HTkdnY56kCQU4hxcmrKwYKHttRXs/1fD/blX+xStMGhc8SUWiarmc5Yy",
	"S/JcmMvAQnTi+7jALyANcjYLBWHaZoRFemJcpIvOaddVbCvd/fP9ClV5Djrscpdx5dOX4tlU7PWmMnAj",
	"7J5AvBMZn0NkfHGh8RdKDneXB+5PNqHQkdpK9HoDTaouZxerku90pKZcZFh+EU+4uvDi+w9GjiuQ5/7w",
	"a6oJ7k+nmIp9KZSejszR1K40GH405wNdWAjucCklO8c0jh8u/18AAAD//2o2n6sK9AAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
