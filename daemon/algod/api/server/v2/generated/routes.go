// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jqkmP1z+vwAAAP//P8aSKPz0AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
