// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/7klSKzS8wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
