// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
